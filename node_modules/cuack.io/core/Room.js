/**
 * @overview 
 * @author Daniel Goberitz <dalgo86@gmail.com>
 */

var socketIO = require('socket.io'),
	utils = require('../utils')
;

function Room(serverInstance, options){
	this.options = utils.merge({},this.options, options);

	this.server = serverInstance;
	this._processOptions();

	this.clients = {};
	this.listeners = {};
}

Room.prototype.options = {
	name: '#default',
	broadcastEventsAllowed: [] // a list of events allowed to broadcast directly from clientSide
};

/**
 * @desc Process the options obtained by the constructor
 * @override
 */
Room.prototype._processOptions = function(){
	this.name = this.options.name;
};

Room.prototype.getName = function(){
	return this.name;
};

/**
 * @throweable
 * @param {String} roomName Nombre del room a crear (url encoded!)
 * @param {mix}	ClientConnectionHandler una clase compatible con el decorador 
 *				ClientConnection
 */
Room.prototype.create = function(){
	var me = this;
	if(undefined === this.name || this.name === '#default'){
		this.name = '#default';
		this.room = this.server.io.sockets;
	}

	if(undefined === this.room){
		this.room = this.server.io.of('/' + this.name);
	}

	this._prepareClientAttender();
	
	this.room.on('connection', function(socket){
console.log('NEW CLIENT on ROOM', me.name, socket.id);

		me.clients[socket.id] = socket;
		socket.on('disconnect', function(){
			delete me.clients[socket.id];
		});
		me._setEventsListeners(socket);
	});
}

Room.prototype._prepareClientAttender = function(){
	var methodName,
		eventName
	;

//console.log('// Room::_prepareClientAttender ////////////////////////////////');

	for(methodName in this){
		if('function' === typeof(this[methodName])){

//console.log('\t Proccessing: ' + methodName);


			if(methodName.indexOf('on') === 0){ // start with on, is an eventListener
//console.log('\t\t On Method (EventListener)');
				eventName = this._parseToEvent(methodName);
				this.listeners[eventName] = this._createEventListener(methodName, eventName);
//console.log('\t\t EventName Associated:' + eventName);
			}else if(methodName.indexOf('rpc') === 0){ // start with rpc, si a method with response
//console.log('\t\t RPC Method (RPC)');
				eventName = this._parseToEvent(methodName);
				this.listeners[eventName] = this._createRPC(methodName, eventName);
//console.log('\t\t EventName Associated:' + eventName);
			}

		}
	}
/*	
	// todo xxx DEBUG REMOVEME
	var dbgL = [];
	for(eventName in this.listeners){
		if(this.listeners.hasOwnProperty(eventName)){
			
			dbgL.push(eventName);
			
		}
	}
	
	console.log('\t// EVENT LISTENERS ////////////////////////////////');
	console.log('\t\t',dbgL);
	console.log('\t\\\\ EVENT LISTENERS \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\');
	
	// todo xxx DEBUG REMOVEME
*/
//console.log('\\\\ Room::_prepareClientAttender \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\');
}

Room.prototype._parseToEvent = function(methodName){
	var eventName;
	if(methodName.indexOf('on') === 0){
		eventName = methodName.substr(2);
	}else if(methodName.indexOf('rpc') === 0){
		eventName = methodName.substr(3);
	}
	eventName = eventName.charAt(0).toLowerCase() + eventName .substring(1);

	return eventName;
}

Room.prototype._createEventListener = function(methodName){
	var me = this;
	/**
	 * @context socket
	 * @param {...} // rest of parameters sended by Client-Side
	 */
	return function(){
		var args = Array.prototype.slice.call(arguments, 0);
		args.reverse();
		args.push( this ); // prepend the socket
		args.reverse();

console.log('EVENT LISTENER: room:' + me.name + ': ', methodName, arguments);

		/**
		 * the onXxxx method receives:
		 * @param {Socket} socket reference
		 * {...} rest of parameters sended by Client-Side
		 */
		return me[methodName].apply(
			me, 
			args
		);
	};
};

Room.prototype._createRPC = function(methodName, eventName){
	var me = this;
	/**
	 * @context socket
	 * @param {String} The RPC Call ID
	 * @param {...} // rest of parameters sended by Client-Side
	 */
	return function(){
		var args = Array.prototype.slice.call(arguments, 1),
			cbkID = arguments[0],
			socket = this
		;

		args.reverse();
		args.push( function(response){ // responseCallback
			socket.emit(eventName + '_r_' + cbkID, response);
		} );
		args.push( this ); // the socket
		args.reverse();

console.log('RPC: room:' + me.name + ': ', methodName, arguments);

		/**
		 * the rpcXxxx method receives:
		 * @param {Socket} socket reference
		 * @param {Function} the callback function to response to ClientSide, accept 1 (one) parameter, the response like a return
		 * {...} rest of parameters sended by Client-Side
		 */
		return me[methodName].apply(
			me, 
			args
		);
	};
};

Room.prototype._setEventsListeners = function(socket){
//console.log('// Room::_setEventsListeners ///////////////////////////////////');
	var eventName, me = this;
	for(eventName in this.listeners){
		if(this.listeners.hasOwnProperty(eventName)){
//console.log('\t Attaching ' + eventName);
			socket.on(eventName, (function(eName, sock){
					return function(){
						me.listeners[eName].apply(sock, arguments);
					}
				}(eventName, socket))
			);
		}
	}
//console.log('\\\\ Room::_setEventsListeners \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\');
}

/**
 * @desc Returns the socket for the socketId received. If the socketId not 
 * exist or is not longer available throw an Exception
 * 
 * @throwable
 * @return {Socket}
 */
Room.prototype.getClient = function(socketId){
	if(undefined === this.clients[socketId]){
		throw 'the client ' + socketId + ' no exists';
	}else{
		return this.clients[socketId];
	}
}

/**
 * @listen broadcast
 * @desc Emits via broadcast the eventName received with the arguments received 
 * directly from ClientSide only if the eventName is in 
 * options.broadcastEventsAllowed
 * 
 */
Room.prototype.onBroadcast = function(socket, eventName, args){
	if(this.options.broadcastEventsAllowed.indexOf(eventName) !== -1){

		var args = Array.prototype.slice.call(arguments,2);

		args.reverse();
		args.push(socket.id);
		args.push(eventName);
		args.reverse();


		socket.broadcast.emit.apply(socket.broadcast, args);

	}
}

module.exports = Room;